# CLAUDE.md - AI Assistant Instructions

This file contains instructions for AI assistants (like Claude) working on the claude-code-portal codebase. It documents the architecture, conventions, and common tasks.

## Project Overview

claude-code-portal is a web-based proxy system for Claude Code sessions built with:
- **Backend**: Rust + Axum + PostgreSQL + Diesel ORM
- **Frontend**: Rust + Yew (WebAssembly)
- **Proxy**: Rust CLI wrapper for claude binary
- **Protocol**: WebSocket-based bidirectional communication

## Architecture Quick Reference

### Workspace Structure

```
claude-code-portal/
├── shared/         # WASM-compatible common types
├── backend/        # Axum server (native only)
├── frontend/       # Yew WASM app (WASM target)
└── proxy/          # CLI wrapper (native only)
```

**Critical**: `shared/` must be WASM-compatible. Do NOT add dependencies with native features.

### Data Flow

```
claude CLI → proxy (WS) → backend (DB) → frontend (WS) → user
```

1. **Proxy** wraps claude CLI, forwards stdin/stdout
2. **Backend** coordinates WebSocket connections, stores in DB
3. **Frontend** displays sessions in browser, sends commands

### Key Files

| File | Purpose | Notes |
|------|---------|-------|
| `shared/src/lib.rs` | Protocol definitions | Must be WASM-compatible |
| `backend/src/main.rs` | Server entry point | AppState contains all dependencies |
| `backend/src/handlers/` | HTTP/WS handlers | All use `State<Arc<AppState>>` |
| `backend/src/schema.rs` | Database schema | Auto-generated by Diesel |
| `frontend/src/lib.rs` | Frontend entry | Yew app root component |
| `proxy/src/main.rs` | Proxy CLI | Wraps claude binary |

## Critical Design Decisions

### 1. Unified AppState Pattern

**All backend handlers use `State<Arc<AppState>>`:**

```rust
pub struct AppState {
    pub dev_mode: bool,
    pub db_pool: DbPool,
    pub session_manager: SessionManager,
    pub oauth_basic_client: Option<BasicClient>,
    pub device_flow_store: Option<DeviceFlowStore>,
}
```

**Why**: Avoids type mismatch errors when Axum tries to extract multiple `State<T>` types.

**When adding handlers**:
```rust
pub async fn new_handler(
    State(app_state): State<Arc<AppState>>,
    // ... other extractors
) -> Result<impl IntoResponse, StatusCode> {
    let pool = &app_state.db_pool;
    let manager = &app_state.session_manager;
    // ...
}
```

### 2. WASM Compatibility in `shared/`

**Rules for `shared/Cargo.toml`**:
- ✅ `serde`, `serde_json` with default features
- ✅ `uuid` with `js` feature (for WASM random)
- ✅ `chrono` with `wasmbind` feature
- ✅ `claude-codes` with `default-features = false, features = ["types"]` (types only, no tokio)
- ❌ NO `tokio` (has native networking)
- ❌ NO `diesel` (native DB)
- ❌ NO `std::fs`, `std::net`, or other native-only APIs

**Example good dependency**:
```toml
uuid = { version = "1.11", features = ["v4", "serde", "js"] }
chrono = { version = "0.4", default-features = false, features = ["serde", "wasmbind"] }
```

**Example bad dependency**:
```toml
tokio = { version = "1", features = ["full"] }  # ❌ Won't compile to WASM
```

### 3. Database Query Patterns

**Always qualify column references to avoid ambiguity**:

```rust
// ❌ BAD - ambiguous if multiple tables have same column
use schema::sessions::dsl::*;
use schema::messages::dsl::*;
sessions.filter(id.eq(some_id))  // Which id?

// ✅ GOOD - explicit table reference
use schema::sessions;
use schema::messages;
sessions::table.filter(sessions::id.eq(some_id))
```

### 4. WebSocket Protocol

**All messages use `shared::ProxyMessage`**:

```rust
pub enum ProxyMessage {
    Register { session_name, auth_token, working_directory },
    ClaudeOutput { content },
    ClaudeInput { content },
    Heartbeat,
    Error { message },
    SessionStatus { status },
}
```

**Flow**:
1. Proxy connects: sends `Register`
2. Backend acknowledges, stores session
3. Frontend connects: receives session list
4. User sends message: `ClaudeInput` → proxy → claude
5. Claude responds: proxy → `ClaudeOutput` → frontend

## Common Tasks

### Adding a New Database Field

1. **Create migration**:
   ```bash
   cd backend
   diesel migration generate add_field_to_table
   ```

2. **Edit `up.sql`**:
   ```sql
   ALTER TABLE sessions ADD COLUMN new_field VARCHAR(255);
   ```

3. **Edit `down.sql`**:
   ```sql
   ALTER TABLE sessions DROP COLUMN new_field;
   ```

4. **Run migration**:
   ```bash
   diesel migration run
   # This regenerates backend/src/schema.rs
   ```

5. **Update model** in `backend/src/models.rs`:
   ```rust
   #[derive(Queryable, Selectable)]
   #[diesel(table_name = sessions)]
   pub struct Session {
       pub id: Uuid,
       // ... existing fields
       pub new_field: String,  // Add this
   }
   ```

### Migration Naming Convention

**All migrations must follow this naming format:**

```
YYYY-MM-DD-HHMMSS_snake_case_description
```

**Examples:**
- `2026-01-15-143022_add_users_table`
- `2026-01-16-091500_add_index_to_sessions`

**Special case:** The initial migration uses `00000000000000_initial_setup` (Diesel convention).

**Enforced by CI:** The `./scripts/check-migration-names.sh` script validates all migration names and runs in GitHub Actions.

**Creating new migrations:**
```bash
cd backend
diesel migration generate add_feature_name
# Creates: YYYY-MM-DD-HHMMSS_add_feature_name/
```

**If renaming existing migrations:** After renaming a migration directory, existing databases need their `__diesel_schema_migrations` table updated. See `backend/migrations/fix_migration_names.sql` for an example.

### Adding a New API Endpoint

1. **Add handler** in `backend/src/handlers/`:
   ```rust
   pub async fn new_endpoint(
       State(app_state): State<Arc<AppState>>,
       Path(param): Path<String>,
   ) -> Result<Json<Response>, StatusCode> {
       // Implementation
       Ok(Json(response))
   }
   ```

2. **Register route** in `backend/src/main.rs`:
   ```rust
   let app = Router::new()
       // ... existing routes
       .route("/api/new-endpoint/:param", get(handlers::module::new_endpoint))
       .with_state(app_state.clone());
   ```

3. **Update `shared/src/lib.rs`** if needed for request/response types

### Adding a Frontend Page

1. **Create page** in `frontend/src/pages/`:
   ```rust
   use yew::prelude::*;

   #[function_component(NewPage)]
   pub fn new_page() -> Html {
       html! {
           <div class="new-page">
               <h1>{"New Page"}</h1>
           </div>
       }
   }
   ```

2. **Export** in `frontend/src/pages/mod.rs`:
   ```rust
   mod new_page;
   pub use new_page::NewPage;
   ```

3. **Add route** in `frontend/src/lib.rs`:
   ```rust
   #[derive(Clone, Routable, PartialEq)]
   enum Route {
       // ... existing routes
       #[at("/new-page")]
       NewPage,
   }

   fn switch(routes: Route) -> Html {
       match routes {
           // ... existing matches
           Route::NewPage => html! { <NewPage /> },
       }
   }
   ```

### Modifying the Protocol

1. **Update `shared/src/lib.rs`**:
   ```rust
   #[derive(Debug, Clone, Serialize, Deserialize)]
   #[serde(tag = "type")]
   pub enum ProxyMessage {
       // ... existing variants
       NewMessageType { field: String },  // Add this
   }
   ```

2. **Update backend handlers** to handle new message type

3. **Update proxy** in `proxy/src/main.rs` to send/receive new type

4. **Update frontend** in `frontend/src/pages/terminal.rs` to handle new type

5. **Test all three components** work together

## Building and Testing

### Quick Commands

```bash
# Development mode (fast iteration)
./scripts/dev.sh start        # Start DB + backend + frontend (background)
./scripts/dev.sh status       # Show status of all services
./scripts/dev.sh logs         # Tail backend logs
./scripts/dev.sh stop         # Stop all services
./scripts/dev.sh restart      # Restart all services
./scripts/dev.sh build        # Rebuild frontend only

# Individual components
cargo build -p backend        # Build backend
cargo build -p claude-portal   # Build proxy CLI
cd frontend && trunk build    # Build frontend (WASM)

# Testing
cargo test --workspace        # All tests
cargo clippy --workspace      # Linter
cargo fmt --check             # Format check

# Database
cd backend
diesel migration run          # Apply migrations
diesel migration revert       # Undo last migration
```

### Build Order Matters

When building from scratch:
1. **shared/** - Must build first (dependency of others)
2. **backend/** - Can build independently
3. **frontend/** - Depends on shared, builds to WASM
4. **proxy/** - Depends on shared

### WASM Build Process

Frontend builds to WebAssembly:
```bash
cd frontend
trunk build          # Development build
trunk build --release # Production build (slow, needs wasm-opt)
```

**Note**: Release builds may fail with `wasm-opt` errors. Use dev builds for development:
```bash
trunk build  # No wasm-opt, faster
```

### Running Locally

**Terminal 1 - Database**:
```bash
docker-compose -f docker-compose.test.yml up db
```

**Terminal 2 - Backend**:
```bash
export DATABASE_URL="postgresql://claude_portal:dev_password_change_in_production@localhost:5432/claude_portal"
cargo run -p backend -- --dev-mode
```

**Terminal 3 - Frontend** (if developing):
```bash
cd frontend
trunk serve  # Auto-reload on changes
```

**Terminal 4 - Proxy** (optional):
```bash
cargo run -p claude-portal -- --backend-url ws://localhost:3000
```

### GitHub CI / Waiting for Checks

**Avoid using `sleep` to wait for CI checks.** Instead, use `gh run watch` to wait for GitHub Actions workflows:

```bash
# Wait for a specific workflow run to complete
gh run watch <run-id> --exit-status

# Example: Wait for CI then merge PR
gh run watch 21103370620 --exit-status && gh pr merge 137 --squash
```

The `--exit-status` flag makes the command exit with non-zero status if the workflow fails, which is useful for chaining commands.

To find the run ID, use `gh pr view <pr-number> --json statusCheckRollup` and look at the `detailsUrl` which contains the run ID.

## Important Constraints

### WASM Compatibility Checklist

When adding dependencies to `shared/`:

- [ ] Check if dependency supports `wasm32-unknown-unknown` target
- [ ] Add only WASM-compatible features
- [ ] Test: `cd shared && cargo build --target wasm32-unknown-unknown`
- [ ] Common WASM-compatible crates:
  - `serde`, `serde_json`
  - `uuid` (with `js` feature)
  - `chrono` (with `wasmbind`)
  - Most serialization/data structure crates

- [ ] Crates that DON'T work with WASM:
  - `tokio` (with default features)
  - `diesel`
  - `reqwest`
  - Anything with native networking or file I/O

### Axum State Management

**Always use unified AppState**:

```rust
// ✅ CORRECT
pub async fn handler(
    State(app_state): State<Arc<AppState>>,
) -> Result<Response, StatusCode> {
    let pool = &app_state.db_pool;
    // ...
}

// ❌ WRONG - will cause type errors
pub async fn handler(
    State(pool): State<DbPool>,  // Different state type
) -> Result<Response, StatusCode> {
    // ...
}
```

**Reason**: Axum's router can only have ONE state type. All handlers must use that same type.

### Database Schema Management

**Never manually edit `backend/src/schema.rs`** - it's auto-generated:

```bash
# After changing migrations:
cd backend
diesel migration run     # Regenerates schema.rs
```

**Always create migrations for schema changes**:
- ✅ `diesel migration generate add_feature`
- ❌ Manual SQL in production

### Authentication Flows

There are **TWO COMPLETELY SEPARATE** authentication flows. Do not confuse them:

#### 1. Web Browser Login (Regular Users)

**Purpose**: User logs into the web dashboard via browser

**Endpoints**:
- `GET /api/auth/google` - Initiates OAuth with Google
- `GET /api/auth/google/callback` - OAuth callback, redirects to `/dashboard`

**Production Flow**:
```
Browser → /api/auth/google
       → Google OAuth consent screen
       → /api/auth/google/callback?code=...&state=<csrf_token>
       → Set session cookie
       → Redirect to /dashboard
```

**Dev Mode Flow**:
```
Browser → /api/auth/google
       → /api/auth/dev-login (auto-login as testing@testing.local)
       → Set session cookie
       → Redirect to /dashboard
```

**Success**: User lands on `/dashboard` with valid session cookie
**Failure**: User sees error page or access denied

---

#### 2. Device Flow (CLI/Proxy Authentication)

**Purpose**: CLI tool authenticates without browser access on the same machine

**This is NOT OAuth** - it's a separate flow that may use OAuth for user verification.

**Endpoints**:
- `POST /api/auth/device/code` - CLI requests a device code
- `GET /api/auth/device?user_code=XXX-XXX` - User enters code in browser
- `GET /api/auth/device-login?device_user_code=XXX-XXX` - Device-specific OAuth (if user not logged in)
- `POST /api/auth/device/approve` - User approves the device
- `POST /api/auth/device/deny` - User denies the device
- `POST /api/auth/device/poll` - CLI polls for completion

**Production Flow**:
```
1. CLI: POST /api/auth/device/code
   Response: { device_code, user_code: "ABC-123", verification_uri }

2. CLI: Display "Visit https://example.com/api/auth/device and enter: ABC-123"

3. User in browser: Visit /api/auth/device?user_code=ABC-123
   - If logged in → Show approval page with hostname/directory
   - If NOT logged in → Redirect to /api/auth/device-login?device_user_code=ABC-123
                      → Google OAuth (with state="device:ABC-123")
                      → Back to /api/auth/device?user_code=ABC-123
                      → Show approval page

4. User clicks "Approve" → POST /api/auth/device/approve
   - Creates JWT token for CLI
   - Marks device flow as complete

5. CLI: POST /api/auth/device/poll (polling every 5s)
   - Returns: { status: "complete", access_token, user_id, user_email }

6. CLI: Stores token in ~/.config/claude-code-portal/config.json
```

**Dev Mode Flow** (no Google OAuth):
```
1-2. Same as production

3. User visits /api/auth/device?user_code=ABC-123
   - If logged in → Show approval page
   - If NOT logged in → /api/auth/device-login?device_user_code=ABC-123
                      → Auto-login as testing@testing.local
                      → Back to /api/auth/device?user_code=ABC-123
                      → Show approval page

4-6. Same as production
```

**Success**: CLI receives JWT token, can connect to backend
**Failure Cases**:
- Invalid/expired code → Error page "Invalid or expired code"
- User denies → Poll returns "denied"
- Timeout (code expires after 15 min) → Poll returns "expired"

---

#### Key Differences

| Aspect | Web Login | Device Flow |
|--------|-----------|-------------|
| Initiator | Browser | CLI tool |
| OAuth state | Random CSRF token | `device:XXX-XXX` prefix |
| Callback redirect | `/dashboard` | `/api/auth/device?user_code=...` |
| Result | Session cookie | JWT token |
| Endpoint | `/api/auth/google` | `/api/auth/device-login` |

**IMPORTANT**: The OAuth callback (`/api/auth/google/callback`) checks if `state` starts with `device:` to determine which flow to complete. Regular OAuth CSRF tokens are random strings that don't have this prefix.

## Troubleshooting Guide for AI Assistants

### "WASM compilation failed: mio not supported"

**Cause**: A dependency in `shared/` or `frontend/` has native-only features.

**Fix**:
1. Check `shared/Cargo.toml` for problematic dependencies
2. Remove or add WASM-compatible features
3. Common culprit: `tokio` with default features
4. Test: `cd shared && cargo build --target wasm32-unknown-unknown`

### "Type mismatch in Axum router"

**Cause**: Different handler functions expect different `State<T>` types.

**Fix**:
1. Ensure ALL handlers use `State<Arc<AppState>>`
2. Check that router is created with `.with_state(app_state.clone())`
3. Don't try to add multiple `.with_state()` calls with different types

### "Diesel query ambiguous column"

**Cause**: Multiple tables have same column name and using glob imports.

**Fix**:
```rust
// Instead of:
use schema::sessions::dsl::*;
use schema::messages::dsl::*;

// Use:
use schema::sessions;
use schema::messages;
sessions::table.filter(sessions::id.eq(...))
```

### "Frontend 404 on /app/"

**Cause**: Backend can't find frontend dist directory.

**Fix**:
1. Check `--frontend-dist` argument to backend
2. Default is `frontend/dist` (relative to repo root)
3. Build frontend: `cd frontend && trunk build`
4. Check backend logs for "Frontend dist not found" warning

### "Proxy won't connect to backend"

**Cause**: Backend not running or URL wrong.

**Fix**:
1. Check backend is running: `curl http://localhost:3000/`
2. Verify WebSocket URL: should be `ws://localhost:3000` (not `wss://`)
3. Check backend logs: `tail -f /tmp/claude-code-portal-backend.log`
4. Try dev mode authentication: backend with `--dev-mode`

## Code Conventions

### Dead Code

**Remove dead code aggressively.** Do not:
- Add `#[allow(dead_code)]` to suppress warnings
- Keep unused structs, functions, or imports "for future use"
- Leave commented-out code in the codebase

If code is unused, delete it. It can be recovered from git history if needed later.

### Error Handling

**Backend handlers**:
```rust
// ✅ GOOD - return StatusCode on error
pub async fn handler(...) -> Result<Json<T>, StatusCode> {
    let data = some_operation()
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(data))
}

// ❌ BAD - don't panic in handlers
pub async fn handler(...) -> Json<T> {
    let data = some_operation().unwrap();  // Will crash server!
    Json(data)
}
```

**Use logging**:
```rust
use tracing::{info, error, warn};

info!("User authenticated: {}", user.email);
error!("Failed to connect to database: {}", err);
warn!("Deprecated API endpoint called");
```

### Naming Conventions

- **Handlers**: Verb-noun format (`list_sessions`, `get_session`, `create_user`)
- **Routes**: Kebab-case (`/api/sessions`, `/auth/google`)
- **Database tables**: Plural snake_case (`users`, `sessions`, `messages`)
- **Rust types**: PascalCase (`AppState`, `ProxyMessage`)
- **Functions**: snake_case (`connect_websocket`, `parse_message`)

### Database Conventions

**Model naming**:
```rust
// Database table: `sessions`
#[derive(Queryable)]
pub struct Session { ... }        // Query result

#[derive(Insertable)]
pub struct NewSession { ... }     // Insert data
```

**Query patterns**:
```rust
// Read
let session = sessions::table
    .find(id)
    .first::<Session>(&mut conn)?;

// Create
diesel::insert_into(sessions::table)
    .values(&new_session)
    .get_result::<Session>(&mut conn)?;

// Update
diesel::update(sessions::table.find(id))
    .set(sessions::status.eq("inactive"))
    .execute(&mut conn)?;

// Delete
diesel::delete(sessions::table.find(id))
    .execute(&mut conn)?;
```

## Security Considerations

### Never Commit

- `.env` file with real credentials
- `config.json` with auth tokens
- Database dumps with user data
- Private keys or OAuth secrets

### Always

- Use `--dev-mode` only in development
- Require HTTPS in production
- Validate all user inputs
- Use parameterized queries (Diesel handles this)
- Rate limit authentication endpoints

## Testing Checklist

When making changes, verify:

- [ ] `cargo test --workspace` passes
- [ ] `cargo clippy --workspace` has no warnings
- [ ] `cargo fmt` applied
- [ ] `cargo build --target wasm32-unknown-unknown -p shared` succeeds
- [ ] `./scripts/dev.sh start` starts without errors
- [ ] Backend accessible at `http://localhost:3000/`
- [ ] Frontend accessible at `http://localhost:3000/`
- [ ] WebSocket connections work (check browser console)
- [ ] Database migrations run successfully

## Quick Reference

### File Locations

| Need to... | Edit this file |
|------------|---------------|
| Add protocol message type | `shared/src/lib.rs` |
| Add database table/column | Create migration in `backend/migrations/` |
| Add API endpoint | `backend/src/handlers/*.rs` + `main.rs` |
| Add frontend page | `frontend/src/pages/*.rs` |
| Change OAuth flow | `backend/src/handlers/auth.rs` |
| Change WebSocket handling | `backend/src/handlers/websocket.rs` |
| Change proxy behavior | `proxy/src/main.rs` |
| Add dependency | `Cargo.toml` (workspace root) |

### Environment Variables

| Variable | Purpose | Required |
|----------|---------|----------|
| `DATABASE_URL` | PostgreSQL connection | Yes |
| `GOOGLE_CLIENT_ID` | OAuth (prod) | Production only |
| `GOOGLE_CLIENT_SECRET` | OAuth (prod) | Production only |
| `GOOGLE_REDIRECT_URI` | OAuth callback | Production only |
| `SESSION_SECRET` | Encryption key | Production only |
| `DEV_MODE` | Bypass OAuth | Development only |
| `HOST` | Bind address | Optional (default: 0.0.0.0) |
| `PORT` | Listen port | Optional (default: 3000) |

### Common Imports

**Backend handlers**:
```rust
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::{IntoResponse, Redirect},
    Json,
};
use diesel::prelude::*;
use std::sync::Arc;
use crate::AppState;
```

**Frontend components**:
```rust
use yew::prelude::*;
use yew_router::prelude::*;
use gloo_net::websocket::{futures::WebSocket, Message};
use shared::ProxyMessage;
```

**Shared types**:
```rust
use serde::{Deserialize, Serialize};
use uuid::Uuid;
```

## Performance Tips

1. **Database queries**: Use `.first()` instead of `.load()` when fetching single record
2. **WebSocket**: Send `Heartbeat` messages to keep connections alive
3. **Frontend**: Use `use_memo` for expensive computations in Yew
4. **Backend**: Database connection pool already configured in `db.rs`

## SHIP Workflow

When the user says **"SHIP"**, execute this workflow:

1. **Create PR**: `gh pr create` with appropriate title and body
2. **Watch CI**: Use `gh pr checks <PR_NUMBER> --watch` to actively monitor all checks
3. **Fix minor CI failures**: If `cargo fmt` or `clippy` fails, fix automatically and push
4. **Re-watch CI**: After any fix, run `gh pr checks <PR_NUMBER> --watch` again
5. **Merge when passing**: `gh pr merge <PR_NUMBER> --squash --delete-branch`
6. **Update local**: `git checkout main && git pull`

**Important**: Do NOT use `--auto` flag for merging. Actively watch CI with `gh pr checks --watch` so failures are caught immediately and can be fixed in the same session.

**CI Failure Handling**:
- **Minor issues** (formatting, clippy warnings): Fix automatically, commit, push, and re-watch CI
- **Substantive issues** (test failures, build errors): Ask the user before making changes

This is a shorthand for the full PR review cycle when the user is confident in the changes.

## When in Doubt

1. Check existing code for similar patterns
2. Run `./scripts/dev.sh start` to verify changes
3. Check `TROUBLESHOOTING.md` for common issues
4. Ensure all tests pass before committing
5. Ask human developer for architectural decisions

## Success Criteria

Your changes are ready when:
- ✅ All four crates build successfully
- ✅ Frontend compiles to WASM without errors
- ✅ `./scripts/dev.sh start` starts all services
- ✅ No clippy warnings
- ✅ Code formatted with rustfmt
- ✅ Existing functionality still works
- ✅ New feature/fix is testable at `http://localhost:3000/`
